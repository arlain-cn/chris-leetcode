package org.chris.leetcode.Collection;

public class PackageTemplate {

    /**
     * 0-1 背包问题二维动态规划解法
     * 思路 1：0-1 背包问题的基本思路
     *
     *
     * 1. 阶段划分
     * 以物品序号和当前背包剩余容量为阶段。
     *
     * 2. 定义状态
     * 令 dp[i][w] 表示前 i 件物品，放入容量不超过 w 的背包时可获得的最大价值。
     * 其中 i 表示考虑前 i 件物品，w 表示当前背包容量。
     *
     * 3. 状态转移方程
     *     > 对于「将前 i 件物品放入容量为 w 的背包，能获得的最大价值」这个子问题，我们只需关注第 i−1 件物品的选择情况（即放或不放），即可将问题递归地转化为只与前 i−1 件物品相关的子问题：
     *     - 不放第 i−1 件物品：此时最大价值为 dp[i−1][w]，即前 i−1 件物品放入容量为 w 的背包的最大价值。
     *     - 放第 i−1 件物品：前提是背包剩余容量足够（w≥weight[i−1]），此时最大价值为 dp[i−1][w−weight[i−1]]+value[i−1]，即前 i−1 件物品放入剩余容量为 w−weight[i−1] 的背包的最大价值，再加上第 i−1 件物品的价值。
     *     >因此，状态转移分两种情况：
     *     - 当 w<weight[i−1] 时，第 i−1 件物品无法放入背包，dp[i][w]=dp[i−1][w]。
     *     - 当 w≥weight[i−1] 时，第 i−1 件物品可选可不选，dp[i][w]=max{dp[i−1][w], dp[i−1][w−weight[i−1]]+value[i−1]}。
     *     >综上，状态转移方程为：
     *
     *     - dp[i][w]=
     *         1. dp[i−1][w], w<weight[i−1]时
     *         2. max{dp[i−1][w], dp[i−1][w−weight[i−1]]+value[i−1]，w≥weight[i−1]时
     *     - **注意：对 i,i-1的使用有些混乱，将前 i 件物品在DP里用dp[i]表示，但是在weight[]、value[]里，第i个元素因为下标从0开始都用weight[i-1]、value[i-1]表示**
     * 4. 初始条件
     * 当背包容量为 0 时，无论有多少物品，最大价值为 0，即 dp[i][0]=0，0≤i≤size。
     * 当没有物品时，无论背包容量多少，最大价值为 0，即 dp[0][w]=0，0≤w≤W。
     * 5. 最终结果
     * 最终答案为 dp[size][W]，即用前 size 件物品，背包容量为 W 时能获得的最大价值。
     *
     * 时间复杂度：O(n×W)，其中 n 为物品数量，W 为背包的载重上限。
     * 空间复杂度：O(n×W)。
     *
     *
     * 基本思路理解：
     * 1、注意：对 i,i-1的使用有些混乱，将前 i 件物品在DP里用dp[i]表示，但是在weight[]、value[]里，第i个元素因为下标从0开始都用weight[i-1]、value[i-1]表示
     * 2、转移方程里当w > weight[i-1]时dp[i][w]=max{dp[i−1][w], dp[i−1][w−weight[i−1]]+value[i−1]},这里w表示背包总容量，当总容量能放下当前物品且放入时，剩余容量为w-weight[i-1],方程里的dp[i−1][w−weight[i−1]]表示在上个物品时，剩余的容量可以放多少价值❗️
     *
     * @param weight int[]，每件物品的重量
     * @param value int[]，每件物品的价值
     * @param W int，背包最大承重
     * @return int，最大可获得价值
     */
    public int zeroOnePackMethod1(int[] weight, int[] value, int W) {
        int size = weight.length;
        // dp[i][w] 表示前 i 件物品，容量不超过 W 时的最大价值
        int[][] dp = new int[size + 1][W + 1];

        // 遍历每一件物品
        for (int i = 1; i <= size; i++) {
            // 遍历每一种可能的背包容量
            for (int w = 0; w <= W; w++) {
                if (w < weight[i - 1]) {
                    // 当前物品放不下，继承上一个状态
                    dp[i][w] = dp[i - 1][w];
                } else {
                    // 当前物品可选，取放与不放的最大值
                    dp[i][w] = Math.max(
                            dp[i - 1][w], // 不放当前物品
                            dp[i - 1][w - weight[i - 1]] + value[i - 1] // 放当前物品
                    );
                }
            }
        }
        // 返回前 size 件物品、容量为 W 时的最大价值
        return dp[size][W];
    }



    /**
     * 0-1 背包问题的思路 2：动态规划 + 滚动数组优化
     *
     * 通过前面的分析可以发现，在依次处理第 1∼n 件物品时，「前 i 件物品的状态」只依赖于「前 i−1 件物品的状态」，与更早之前的状态无关。
     * 换句话说，状态转移时只涉及当前行（第 i 行）的 dp[i][w] 和上一行（第 i−1 行）的 dp[i−1][w]、dp[i−1][w−weight[i−1]]。
     * 因此，我们无需保存所有阶段的状态，只需保留当前阶段和上一阶段的状态即可。可以用两个一维数组分别存储相邻两阶段的所有状态：dp[0][w] 存储 dp[i−1][w]，dp[1][w] 存储 dp[i][w]。
     * 进一步优化时，其实只需一个一维数组 dp[w]，利用「滚动数组」思想，将动态规划的第一维去掉，从而实现空间优化。
     *
     * 思路 2：动态规划 + 滚动数组优化
     * 1. 阶段划分
     * 以当前背包的剩余容量 w 作为阶段。
     *
     * 2. 定义状态
     * 令 dp[w] 表示：在背包容量不超过 w 的情况下，能够获得的最大总价值。
     *
     * 3. 状态转移方程
     * 状态转移如下：
     * dp[w]=
     *     - dp[w],        w<weight[i−1]
     *     - max{dp[w], dp[w−weight[i−1]]+value[i−1]},     w≥weight[i−1]
     * 在处理第 i 件物品时，dp[w] 只依赖于上一阶段（即第 i−1 件物品处理完后）的 dp[w] 和 dp[w−weight[i−1]]。因此，为了避免状态被提前覆盖，必须对 w 采用从大到小（即从 W 到 0）的逆序遍历。这样可以确保每次转移用到的 dp[w−weight[i−1]] 仍然是上一阶段的值。（因为w每次是用减的）
     *
     * 如果采用从小到大（正序）遍历，则 dp[w−weight[i−1]] 可能已经被本轮更新，导致状态转移错误。
     *
     * 实际上，当 w<weight[i−1] 时，当前物品无法放入背包，dp[w] 保持不变，无需更新。因此逆序遍历时只需从 W 遍历到 weight[i−1]。
     *
     * 4. 初始条件
     * 对于所有 0≤w≤W，dp[w]=0，表示背包容量为 w 时，尚未放入任何物品，最大价值为 0。
     *
     * 5. 最终结果
     * 最终答案为 dp[W]，即背包容量为 W 时能够获得的最大总价值。
     *
     * 0-1 背包问题的滚动数组优化解法思路：
     * 1、在依次处理第 1∼n 件物品时，「前 i 件物品的状态」只依赖于「前 i−1 件物品的状态」，与更早之前的状态无关。 换句话说，状态转移时只涉及当前行（第 i 行）的 dp[i][w] 和上一行（第 i−1 行）的 dp[i−1][w]、dp[i−1][w−weight[i−1]]。
     * 2、其实只需一个一维数组 dp[w]，利用「滚动数组」思想，将动态规划的第一维去掉，从而实现空间优化。
     * @param weight int[]，每件物品的重量
     * @param value int[]，每件物品的价值
     * @param W int，背包最大承重
     * @return int，背包可获得的最大价值
     */
    public int zeroOnePackMethod2(int[] weight, int[] value, int W) {
        int size = weight.length;
        // dp[w] 表示容量为 w 时背包可获得的最大价值
        int[] dp = new int[W + 1];

        // 遍历每一件物品
        for (int i = 0; i < size; i++) {
            // 必须逆序遍历容量，防止状态被提前覆盖
            for (int w = W; w >= weight[i]; w--) {
                // 状态转移：不选第 i 件物品 or 选第 i 件物品
                // dp[w] = max(不选, 选)
                dp[w] = Math.max(dp[w], dp[w - weight[i]] + value[i]);
                // 解释：
                // dp[w]：不选第 i 件物品，价值不变
                // dp[w - weight[i]] + value[i]：选第 i 件物品，容量减少，相应加上价值
            }
        }

        return dp[W];
    }



}
